<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FF14 潜水艦：帰還時刻管理（ver.XX）</title>
<meta name="theme-color" content="#0f1220" />
<style>
  :root { --bg:#0f1220; --card:#171a2b; --border:#232946; --text:#e6ebff; --muted:#9aa3c7; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
  header{padding:16px;border-bottom:1px solid var(--border)}
  h1{margin:0;font-size:18px}
  main{max-width:980px;margin:0 auto;padding:16px;display:grid;gap:16px}
  .card{background:#161a2b;border:1px solid var(--border);border-radius:12px;padding:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  input,button,select{border-radius:10px;border:1px solid var(--border);background:#0c1020;color:#e6ebff;padding:8px 10px}
  input.name{width:220px}
  button{cursor:pointer}
  table{width:100%;border-collapse:collapse}
  th,td{padding:8px;border-bottom:1px solid var(--border);text-align:left}
  .small{font-size:12px;color:var(--muted)}
  .preview{max-width:100%;border:1px solid var(--border);border-radius:8px;display:none;margin-top:6px}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#24304f;color:#cfe;border:1px solid #2f3a64}
  details{border:1px dashed var(--border);border-radius:10px;padding:6px 10px}
  summary{cursor:pointer}
</style>
</head>
<body>
<header class="row">
  <h1 id="appTitle">FF14 潜水艦：帰還時刻管理（ver.XX）</h1>
</header>

<main>
  <section class="card">
    <div class="row">
      <input id="file" type="file" accept="image/*" />
      <button id="btnOcr" disabled>OCRして帰還時刻を更新</button>
      <span class="small">ファイル名は <code>ffxiv_YYYYMMDD_HHMMSS_*.png</code> を基準にします。</span>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="btnNotify">通知を許可</button>
      <label class="row small" style="gap:6px">
        アラーム:
        <select id="alarmMinutes">
          <option value="0">なし</option>
          <option value="1">1分前</option>
          <option value="5" selected>5分前</option>
          <option value="10">10分前</option>
          <option value="30">30分前</option>
        </select>
      </label>
      <button id="btnExport">Googleカレンダー（.ics）出力</button>
      <span class="small">※ .ics は VALARM を含みます</span>
    </div>
    <img id="preview" class="preview" alt="preview"/>
  </section>

  <section class="card">
    <table>
      <thead>
        <tr><th>潜水艦名（編集可）</th><th>帰還時間</th><th>残り</th></tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
    <div class="small" style="margin-top:6px">
      初期値: <code>submarine-1</code> ～ <code>submarine-4</code>。編集内容と帰還時刻はブラウザに保存されます。
    </div>
  </section>

  <section class="card">
    <details open>
      <summary>OCRログ</summary>
      <div id="ocrStatus" class="small" style="margin:6px 0">画像を選ぶとOCRできます。</div>
      <div id="rawText" class="small" style="white-space:pre-wrap;display:none"></div>
    </details>
  </section>

  <section class="card">
    <details>
      <summary>内蔵テスト</summary>
      <div id="tests" class="small"></div>
    </details>
  </section>
</main>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<script>
/* ====== バージョン表記 ====== */
const APP_VERSION = '1.0.4';
(function applyVersion(){
  const title = `FF14 潜水艦：帰還時刻管理（ver.${APP_VERSION}）`;
  document.title = title;
  const h1 = document.getElementById('appTitle'); if(h1) h1.textContent = title;
})();

/* ====== 定数・ユーティリティ ====== */
const DEFAULT_NAMES = ['submarine-1','submarine-2','submarine-3','submarine-4'];
const STORE = 'ff14-sub-eta-with-names-v2';
const STORE_FIRED = 'ff14-sub-eta-with-names-v2-fired';

const z = n => String(n).padStart(2,'0');
function fmtLocal(d){ return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())} ${z(d.getHours())}:${z(d.getMinutes())}:${z(d.getSeconds())}`; }
function humanLeft(ms){
  if(!isFinite(ms)) return '-';
  const neg=ms<0; ms=Math.abs(ms);
  const s=Math.floor(ms/1000);
  const h=Math.floor(s/3600), m=Math.floor((s%3600)/60), ss=s%60;
  return (neg?'-':'')+`${h}時間 ${m}分 ${z(ss)}秒`;
}
function normalizeJaSpaces(s){
  let t = s.replace(/[０-９]/g, d => String.fromCharCode(d.charCodeAt(0)-0xFEE0))
           .replace(/[：]/g,':').replace(/\u3000/g,' ')
           .replace(/[ \t]+/g,' ').replace(/\s+\n/g,'\n').trim();
  // 日本語の間の空白を除去（OCR対策）
  t = t.replace(/([\u3040-\u30FF\u3400-\u9FFF])\s+(?=[\u3040-\u30FF\u3400-\u9FFF])/g, '$1');
  return t;
}
/** ffxiv_YYYYMMDD_HHMMSS_xxx.png → Date(ローカル) */
function parseFileTimestamp(filename){
  const m = filename.match(/ffxiv_(\d{8})_(\d{6})/i);
  if(!m) return null;
  const y=+m[1].slice(0,4), mo=+m[1].slice(4,6)-1, d=+m[1].slice(6,8);
  const hh=+m[2].slice(0,2), mm=+m[2].slice(2,4), ss=+m[2].slice(4,6);
  return new Date(y,mo,d,hh,mm,ss);
}

/** “Submarine” （空白混じりOK） */
const SUB_RE = /S\s*U\s*B\s*M\s*A\s*R\s*I\s*N\s*E/i;
const SUB_NUM_RE = /S\s*U\s*B\s*M\s*A\s*R\s*I\s*N\s*E\s*[-‐-‒–—ー]?\s*([0-9]+)/i;

/* --- 数字に強いトークン変換（行内のみ） --- */
function tokenToNumber(tok){
  if(!tok) return null;
  let t = tok;
  t = t.replace(/[０-９]/g, d => String.fromCharCode(d.charCodeAt(0)-0xFEE0));
  // 形が似た誤認を代替（限定的に）
  t = t.replace(/[Oo]/g,'0')
       .replace(/[Il|]/g,'1')
       .replace(/[Z乙二]/g,'2')
       .replace(/[Ss]/g,'5');
  t = t.replace(/\s+/g,'');           // 桁内スペース削除
  t = t.replace(/[^\d]/g,'');         // 非数字除去
  if(!t) return null;
  return parseInt(t,10);
}

/* --- 行テキストから (h, m) を抽出：日にも対応 --- */
function readHMFromLineText(t){
  const s = normalizeJaSpaces(t);

  // 1) 日＋時間＋分（空白は任意）
  let m = s.match(/残り時間\s*([0-9０-９OIlZ乙二\s]{1,3})\s*日\s*([0-9０-９OIlZ乙二\s]{1,3})\s*時間\s*([0-9０-９OIlZ乙二\s]{1,3})\s*分/i);
  if(m){
    const d = tokenToNumber(m[1]), h = tokenToNumber(m[2]), mm = tokenToNumber(m[3]);
    if(d!=null && h!=null && mm!=null) return { h: d*24 + h, mm };
  }

  // 2) 時間＋分のみ
  m = s.match(/残り時間\s*([0-9０-９OIlZ乙二\s]{1,6})\s*時間\s*([0-9０-９OIlZ乙二\s]{1,3})\s*分/i);
  if(m){
    const h = tokenToNumber(m[1]), mm = tokenToNumber(m[2]);
    if(h!=null && mm!=null) return { h, mm };
  }

  return null;
}

/* --- ラインの bbox を取得（tesseract.js の表記ゆれを吸収） --- */
function getBBox(L){
  return L?.bbox || L?.bbl || L?.boundingBox || null;
}

/* --- クラスタリングで同じブロックの候補群を選ぶ --- */
function pickBestCluster(cands, imgW){
  if(cands.length===0) return [];
  // 行高の中央値 → クラスタ閾値
  const heights = cands.map(c=>c.hgt).sort((a,b)=>a-b);
  const med = heights[Math.floor(heights.length/2)] || 24;
  const th = Math.max(20, Math.min(60, med * 1.5));  // 20〜60の範囲で自動調整

  // yでソートして近いものを同クラスタへ
  cands.sort((a,b)=>a.cy-b.cy);
  const clusters = [];
  for(const c of cands){
    const last = clusters[clusters.length-1];
    if(!last || Math.abs(c.cy - last.lastCy) > th){
      clusters.push({ items:[c], lastCy:c.cy });
    }else{
      last.items.push(c); last.lastCy = c.cy;
    }
  }

  // スコア：行数優先 → xばらつき小 → 画面中央に近い
  let best = clusters[0], bestScore = -1;
  for(const cl of clusters){
    const xs = cl.items.map(i=>i.x0);
    const ys = cl.items.map(i=>i.cy);
    const xspread = Math.max(...xs) - Math.min(...xs);
    const vspread = Math.max(...ys) - Math.min(...ys);
    const cx = (Math.max(...xs)+Math.min(...xs))/2;
    const centerDist = Math.abs(cx - imgW/2);
    const score = cl.items.length*1000 - xspread - vspread - centerDist*0.1;
    if(score > bestScore){ bestScore = score; best = cl; }
  }
  return best.items;
}

/**
 * OCR結果(data)＋画像(imgEl) → 分配列を作成
 *  - まず各行から HM を抽出
 *  - bbox がある行でクラスタリングし、最適なブロックを選択
 *  - Submarine が含まれていれば番号順で優先
 */
async function buildMinutesFromOCR(worker, data, imgEl){
  const lineObjs = [];
  for(const L of (data.lines || [])){
    const text = L.text || '';
    const s = normalizeJaSpaces(text);
    // 「探索中」「残り時間」「時間」「分」が同一行
    if(!/探索/.test(s) || !/残り/.test(s) || !/時間/.test(s) || !/分/.test(s)) continue;

    const hm = readHMFromLineText(text);
    if(!hm) continue;

    const bb = getBBox(L);
    const isSub = SUB_RE.test(s);
    const numM = s.match(SUB_NUM_RE);

    lineObjs.push({
      mins: hm.h*60 + hm.mm,
      isSub,
      num: numM ? +numM[1] : null,
      x0: bb ? bb.x0 : 0,
      x1: bb ? bb.x1 : 0,
      cy: bb ? (bb.y0 + bb.y1)/2 : 0,
      hgt: bb ? (bb.y1 - bb.y0) : 24
    });
  }

  if(lineObjs.length===0) return [];

  let chosen = [];
  // Submarine で4本以上拾えていれば、それを番号順
  const subs = lineObjs.filter(v=>v.isSub);
  if(subs.length>=2){ // 2本以上あれば“それっぽい”と判断
    chosen = subs.sort((a,b)=>{
      if(a.num!=null && b.num!=null) return a.num-b.num;
      return a.cy-b.cy;
    });
  }else{
    // bbox を使って最良クラスタを選択
    const imgW = imgEl?.naturalWidth || 2000;
    const pool = lineObjs.filter(v=>v.x1>0 || v.x0>0);
    chosen = pickBestCluster(pool.length?pool:lineObjs, imgW).sort((a,b)=>a.cy-b.cy);
  }

  return chosen.slice(0,4).map(v=>v.mins);
}

/* ====== 状態（永続化） ====== */
function makeDefaultRows(){ return DEFAULT_NAMES.map(n=>({name:n, eta:null})); }
function load(){
  try{
    const raw = localStorage.getItem(STORE);
    if(raw){
      const parsed = JSON.parse(raw);
      if(Array.isArray(parsed) && parsed.length===4){
        return parsed.map((r,i)=>({ name: r.name || DEFAULT_NAMES[i], eta: r.eta || null }));
      }
    }
  }catch{}
  return makeDefaultRows();
}
function save(rows){ localStorage.setItem(STORE, JSON.stringify(rows)); }
function loadFired(){ try{ return new Set(JSON.parse(localStorage.getItem(STORE_FIRED)||'[]')); }catch{ return new Set(); } }
function saveFired(set){ try{ localStorage.setItem(STORE_FIRED, JSON.stringify([...set])); }catch{} }

const state = { rows: load(), fired: loadFired() };

/* ====== 描画 ====== */
function render(){
  const tbody = document.getElementById('tbody'); tbody.innerHTML='';
  state.rows.forEach((r,i)=>{
    const eta = r.eta ? new Date(r.eta) : null;
    const left = eta ? (eta.getTime() - Date.now()) : NaN;
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input class="name" data-i="${i}" value="${r.name}" /></td>
      <td>${eta ? `<span class="pill" data-eta="${eta.toISOString()}">${fmtLocal(eta)}</span>` : '-'}</td>
      <td class="left" data-left="${r.eta||''}">${eta?humanLeft(left):'-'}</td>`;
    tbody.appendChild(tr);
  });
}

/* 名前編集を保存 */
document.addEventListener('input', (ev)=>{
  const el = ev.target;
  if(el && el.classList && el.classList.contains('name')){
    const i = +el.getAttribute('data-i');
    let val = (el.value||'').trim();
    if(!val) val = DEFAULT_NAMES[i];
    state.rows[i].name = val;
    save(state.rows);
    if(el.value.trim()==='') el.value = val;
  }
});

/* ====== カウントダウン & 通知 ====== */
function tick(){
  const mins = +document.getElementById('alarmMinutes').value || 0;
  const canNotify = ('Notification' in window) && Notification.permission==='granted' && mins>0;

  document.querySelectorAll('[data-left]').forEach(el=>{
    const etaISO = el.getAttribute('data-left'); if(!etaISO) { el.textContent='-'; return; }
    const eta = new Date(etaISO).getTime();
    const left = eta - Date.now();
    el.textContent = left<=0 ? '帰還済み' : humanLeft(left);

    if(canNotify){
      const fireKey = `${etaISO}|m${mins}`;
      const fireAt = eta - mins*60000;
      if(!state.fired.has(fireKey) && Date.now() >= fireAt && left > -60*1000){
        new Notification('潜水艦 帰還間近', { body: `${mins}分後に帰還（${fmtLocal(new Date(eta))}）` });
        state.fired.add(fireKey); saveFired(state.fired);
      }
    }
  });
}

/* ====== OCR（ETAのみ更新） ====== */
document.getElementById('file').addEventListener('change', ev=>{
  const f = ev.target.files?.[0];
  document.getElementById('btnOcr').disabled = !f;
  if(!f) return;
  const url = URL.createObjectURL(f);
  const img = document.getElementById('preview'); img.src = url; img.style.display = 'block';
  document.getElementById('ocrStatus').textContent = '準備OK：OCRを開始できます。';
  document.getElementById('rawText').style.display='none';
});

document.getElementById('btnOcr').addEventListener('click', async()=>{
  const f = document.getElementById('file').files?.[0]; if(!f) return;

  const baseTime = parseFileTimestamp(f.name) || new Date();
  document.getElementById('ocrStatus').textContent = `OCR処理中…（基準時刻: ${fmtLocal(baseTime)}）`;

  const imgEl = document.getElementById('preview');
  if(!imgEl.complete) await imgEl.decode();

  const worker = await Tesseract.createWorker('jpn+eng');
  try{
    await worker.setParameters({ tessedit_pageseg_mode:'3', user_defined_dpi:'300' });
    const { data } = await worker.recognize(f);
    const raw = data.text || '';
    document.getElementById('rawText').textContent = raw; document.getElementById('rawText').style.display='block';

    const minsList = await buildMinutesFromOCR(worker, data, imgEl);
    if(!minsList.length){
      document.getElementById('ocrStatus').textContent = '該当形式の行が見つかりませんでした。';
      return;
    }
    // 先頭から4件の ETA を更新（名前は保持）
    for(let i=0;i<4;i++){
      const m = minsList[i];
      if(typeof m === 'number'){
        const eta = new Date(baseTime.getTime() + m*60000);
        state.rows[i].eta = eta.toISOString();
      }
    }
    save(state.rows);
    render();
    document.getElementById('ocrStatus').textContent = `検出 ${minsList.length} 件（反映 ${Math.min(4, minsList.length)} 件）。`;
  }catch(e){
    console.error(e);
    document.getElementById('ocrStatus').textContent = 'OCR失敗：画像を明るく/拡大して再試行してください。';
  }finally{
    await worker.terminate();
  }
});

/* ====== 通知ボタン / .ics 出力 ====== */
document.getElementById('btnNotify').addEventListener('click', async()=>{
  if(!('Notification' in window)){ alert('このブラウザは通知に未対応です'); return; }
  const p = await Notification.requestPermission();
  alert(p==='granted' ? '通知を許可しました（GitHub Pagesのhttpsで動作）' : '通知が許可されませんでした');
});
function toICSUTC(dt){
  const t = new Date(dt.getTime()-dt.getTimezoneOffset()*60000).toISOString();
  return t.replace(/[-:]/g,'').replace(/\.\d{3}Z/,'Z');
}
document.getElementById('btnExport').addEventListener('click', ()=>{
  const minsAlarm = +document.getElementById('alarmMinutes').value || 0;
  const entries = state.rows.map(r=> r.eta ? { title:`${r.name} 帰還`, eta:new Date(r.eta) } : null).filter(Boolean);
  if(!entries.length){ alert('エクスポート対象の帰還時刻がありません'); return; }

  const lines = ['BEGIN:VCALENDAR','VERSION:2.0','PRODID:-//FF14-SubTimer//JP','CALSCALE:GREGORIAN','METHOD:PUBLISH'];
  entries.forEach(({title, eta},i)=>{
    const dt = toICSUTC(eta);
    const end = toICSUTC(new Date(eta.getTime()+60*1000)); // 1分イベント
    lines.push('BEGIN:VEVENT', `UID:${Date.now()}-${i}@ff14-sub`, `DTSTAMP:${dt}`, `DTSTART:${dt}`, `DTEND:${end}`, `SUMMARY:${title}`);
    if(minsAlarm>0){ lines.push('BEGIN:VALARM','ACTION:DISPLAY',`TRIGGER:-PT${minsAlarm}M`,'DESCRIPTION:Submarine return','END:VALARM'); }
    lines.push('END:VEVENT');
  });
  lines.push('END:VCALENDAR');

  const blob = new Blob([lines.join('\r\n')], {type:'text/calendar'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'ff14_submarine_returns.ics'; a.click();
});

/* ====== テスト（主要パターン） ====== */
function test(name, fn){
  const el=document.getElementById('tests');
  try{ fn(); el.innerHTML += `✅ ${name}<br/>`; }
  catch(e){ el.innerHTML += `❌ ${name} — ${e.message}<br/>`; console.error(name, e); }
}
function assert(c,m){ if(!c) throw new Error(m||'assert'); }
(function runTests(){
  test('HM抽出: 時間のみ', ()=>{
    const hm = readHMFromLineText('... 残り時間 22時間10分 ]');
    assert(hm && hm.h===22 && hm.mm===10,'22h10m');
  });
  test('HM抽出: 日+時間+分（空白あり）', ()=>{
    const hm = readHMFromLineText('残り時間 1日 6時間33分');
    assert(hm && hm.h===30 && hm.mm===33,'1日6時間33分→30h33m');
  });
  test('Submarine無しでもクラスタ選択', ()=>{
    const fake = [
      {text:'Bonfire [Rank] [探索中:残り時間 2時間18分]', bbox:{x0:50,x1:450,y0:50,y1:70}},
      {text:'Siipi [Rank] [探索中:残り時間 22時間17分]', bbox:{x0:50,x1:450,y0:75,y1:95}},
      {text:'KAERU-01 [Rank] [探索中:残り時間 1日1時間49分]', bbox:{x0:500,x1:1000,y0:300,y1:320}},
      {text:'USAGI-02 [Rank] [探索中:残り時間 1時間50分]', bbox:{x0:500,x1:1000,y0:325,y1:345}},
      {text:'SUGOKU [Rank] [探索中:残り時間 18時間30分]', bbox:{x0:500,x1:1000,y0:350,y1:370}},
      {text:'PENGUIN [Rank] [探索中:残り時間 18時間28分]', bbox:{x0:500,x1:1000,y0:375,y1:395}}
    ];
    // 疑似 data/画像サイズ
    const data = { lines: fake };
    const img = { naturalWidth: 1200 };
    buildMinutesFromOCR({ setParameters: async()=>{}, recognize: async()=>({data:{text:''}}) }, data, img).then(out=>{
      // 後段クラスタ（KAERU..PENGUIN）を拾って4件になるはず
      assert(out.length===4 && out[0]===24*1+1*60+49-60, 'クラスタ選択'); // ざっくり検証
    });
  });
})();
render();
setInterval(tick, 1000);
</script>
</body>
</html>
